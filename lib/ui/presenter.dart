import 'dart:async';

import 'package:flutter/scheduler.dart';
import 'package:flutter/widgets.dart';
import 'package:meta/meta.dart';
import 'package:simple_framework/simple_framework.dart';

abstract class Presenter<B extends Bloc, E extends Entity, S extends Screen>
    extends StatefulWidget {
  @override
  @nonVirtual
  _PresenterState<B, E, S> createState() => _PresenterState<B, E, S>();

  Stream<E> getViewModelStream(B bloc);

  S buildScreen(BuildContext context, B bloc, E viewModel);

  Widget buildLoadingScreen(BuildContext context) {
    return const SizedBox.shrink(key: Key('waitingForStream'));
  }

  Widget buildErrorScreen(BuildContext context, Object? error) {
    return const SizedBox.shrink(key: Key('noContentFromStream'));
  }

  /// By default, the view entity pipe should have a onListen callback on the
  /// bloc, causing to be unnecessary to create an event to retrieve it. If the
  /// view entity is generated by a complex logic, this method can be overridden
  /// to call an specific event.
  void sendViewModelRequest(B bloc) {}

  void onViewModelUpdate(BuildContext context, B bloc, E viewModel) {}
}

class _PresenterState<B extends Bloc, E extends Entity, S extends Screen>
    extends State<Presenter<B, E, S>> {
  late B _bloc;
  Widget? _child;
  StreamSubscription<E>? _subscription;

  @override
  void initState() {
    super.initState();
    _bloc = context.bloc<B>();
    _subscribe();
    SchedulerBinding.instance!.addPostFrameCallback(
      (_) => widget.sendViewModelRequest(_bloc),
    );
  }

  @override
  Widget build(BuildContext context) {
    return _child ?? widget.buildLoadingScreen(context);
  }

  @override
  void dispose() {
    _unsubscribe();
    super.dispose();
  }

  void _subscribe() {
    widget.getViewModelStream(_bloc).listen(
      (viewModel) {
        widget.onViewModelUpdate(context, _bloc, viewModel);
        _child = widget.buildScreen(context, _bloc, viewModel);
        setState(() {});
      },
      onError: (error, stackTrace) {
        _child = widget.buildErrorScreen(context, error);
        setState(() {});
      },
    );
  }

  void _unsubscribe() {
    _subscription?.cancel();
    _subscription = null;
  }
}
